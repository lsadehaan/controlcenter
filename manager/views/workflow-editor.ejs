<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title %> - Control Center</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow@0.0.60/dist/drawflow.min.css">
  <style>
    /* Editor Layout */
    .editor-layout {
      display: flex;
      gap: 0;
      margin-top: 20px;
      height: 650px;
    }
    .node-palette {
      width: 220px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      max-height: 600px;
      overflow-y: auto;
    }
    .node-palette h3 {
      margin: 15px 0 10px 0;
      color: #333;
      font-size: 14px;
      font-weight: 600;
      border-bottom: 2px solid #e0e0e0;
      padding-bottom: 5px;
    }
    .node-palette h3:first-child {
      margin-top: 0;
    }
    .palette-item {
      padding: 8px 12px;
      margin: 5px 0;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      cursor: move;
      transition: all 0.2s;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .palette-item:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      transform: translateX(3px);
    }
    .palette-item.dragging {
      opacity: 0.5;
    }
    .properties-panel {
      width: 350px;
      min-width: 250px;
      max-width: 600px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 0;
      height: 100%;
      overflow-y: auto;
      flex-shrink: 0;
    }
    /* Splitter */
    .splitter {
      width: 8px;
      background: transparent;
      cursor: col-resize;
      position: relative;
      flex-shrink: 0;
    }
    .splitter:hover {
      background: #e9ecef;
    }
    .splitter:active {
      background: #dee2e6;
    }
    .property-field {
      margin-bottom: 15px;
    }
    .property-field label {
      display: block;
      margin-bottom: 5px;
      font-size: 12px;
      color: #666;
      font-weight: 600;
    }
    .property-field .form-input {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 13px;
    }
    .property-field textarea.form-input {
      min-height: 80px;
      resize: vertical;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 12px;
    }
    
    /* Drawflow Canvas */
    #drawflow {
      position: relative;
      flex: 1;
      height: 600px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      background: #fafbfc;
      background-size: 20px 20px;
      background-image: 
        linear-gradient(to right, #e9ecef 1px, transparent 1px),
        linear-gradient(to bottom, #e9ecef 1px, transparent 1px);
    }
    
    /* Node Styling */
    .drawflow .drawflow-node {
      position: relative;
      width: 220px !important;
      max-width: 220px !important;
      border: none !important;
      background: transparent !important;
      padding: 0 !important;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
      transition: filter 0.2s;
    }
    .drawflow-node:hover {
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.15));
    }
    .drawflow-node.selected > div:first-child {
      box-shadow: 0 0 0 3px #007bff !important;
    }
    
    /* Node Types */
    .node-trigger, .node-action, .node-condition, .node-output {
      position: relative;
      width: 100%;
      border-radius: 10px;
      padding: 0;
      background: white;
      border: 2px solid;
      box-sizing: border-box;
    }
    
    .node-trigger {
      border-color: #0288d1;
    }
    .node-trigger .node-header {
      background: linear-gradient(135deg, #03a9f4 0%, #0288d1 100%);
      color: white;
    }
    
    .node-action {
      border-color: #f57c00;
    }
    .node-action .node-header {
      background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
      color: white;
    }
    
    .node-condition {
      border-color: #7b1fa2;
    }
    .node-condition .node-header {
      background: linear-gradient(135deg, #ab47bc 0%, #7b1fa2 100%);
      color: white;
    }
    
    .node-output {
      border-color: #388e3c;
    }
    .node-output .node-header {
      background: linear-gradient(135deg, #66bb6a 0%, #388e3c 100%);
      color: white;
    }
    
    .node-header {
      font-weight: 600;
      padding: 10px 15px;
      font-size: 14px;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .node-header::before {
      content: '';
      display: inline-block;
      width: 6px;
      height: 6px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
    }
    
    .node-content {
      padding: 10px 15px;
      font-size: 12px;
      color: #555;
      background: rgba(255,255,255,0.95);
    }
    .node-content small {
      display: block;
      margin-top: 4px;
      opacity: 0.7;
      font-style: italic;
    }
    
    /* Input/Output Ports - IMPORTANT: These must be visible */
    .drawflow-node .input, .drawflow-node .output {
      position: absolute !important;
      width: 15px !important;
      height: 15px !important;
      border: 2px solid #495057 !important;
      background: white !important;
      border-radius: 50% !important;
      z-index: 10 !important;
      cursor: crosshair !important;
    }
    .drawflow-node .input {
      left: -8px !important;
      top: 50% !important;
      transform: translateY(-50%);
    }
    .drawflow-node .output {
      right: -8px !important;
      top: 50% !important;
      transform: translateY(-50%);
    }
    .drawflow-node .input:hover, .drawflow-node .output:hover {
      background: #007bff !important;
      border-color: #0056b3 !important;
      width: 18px !important;
      height: 18px !important;
    }
    
    /* Multiple inputs/outputs positioning */
    .drawflow-node .inputs, .drawflow-node .outputs {
      position: absolute;
      top: 0;
      width: 0;
      height: 100%;
    }
    .drawflow-node .inputs {
      left: 0;
    }
    .drawflow-node .outputs {
      right: 0;
    }
    
    /* Drawflow SVG container fix */
    .drawflow svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    /* Connection Lines */
    .drawflow svg path {
      stroke: #495057;
      stroke-width: 3px;
      fill: none;
      stroke-linecap: round;
      pointer-events: auto;
    }
    .drawflow svg path:hover {
      stroke: #007bff;
      stroke-width: 4px;
    }
    
    /* Editor Controls */
    .editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
      border-bottom: 1px solid #dee2e6;
    }
    .editor-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .editor-controls .form-input {
      width: 200px;
    }
    .editor-controls .form-input:disabled {
      background: #f0f0f0;
      color: #666;
      cursor: not-allowed;
    }
    
    /* Buttons */
    .btn {
      padding: 8px 16px;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      background: white;
      color: #495057;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn:hover {
      background: #f8f9fa;
      border-color: #adb5bd;
    }
    .btn-primary {
      background: #007bff;
      border-color: #007bff;
      color: white;
    }
    .btn-primary:hover {
      background: #0056b3;
      border-color: #0056b3;
    }
    .btn-sm {
      padding: 5px 10px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-brand">
        <h1>Control Center</h1>
      </div>
      <ul class="nav-menu">
        <li><a href="/">Dashboard</a></li>
        <li><a href="/agents">Agents</a></li>
        <li><a href="/workflows">Workflows</a></li>
        <li><a href="/workflow-editor" class="active">Editor</a></li>
        <li><a href="/alerts">Alerts</a></li>
        <li><a href="/logs">Logs</a></li>
        <li><a href="/settings">Settings</a></li>
      </ul>
    </div>
  </nav>
  
  <main class="main-content">
    <div class="container-fluid">
      <div class="editor-header">
        <h2>Workflow Editor</h2>
        <div class="editor-controls">
          <input type="text" id="workflow-name" placeholder="Workflow Name" class="form-input">
          <button class="btn btn-primary" onclick="saveWorkflow()">Save Workflow</button>
          <button class="btn" onclick="clearWorkflow()">Clear</button>
          <button class="btn" onclick="exportWorkflow()">Export</button>
          <button class="btn" onclick="importWorkflow()">Import</button>
        </div>
      </div>
      
      <div class="editor-layout">
        <div class="node-palette">
          <h3>Triggers</h3>
          <div class="palette-item" draggable="true" data-node="file-trigger">
            <i class="icon">üìÅ</i> File Trigger
          </div>
          <div class="palette-item" draggable="true" data-node="filewatcher-trigger">
            <i class="icon">üëÅÔ∏è</i> File Watcher Trigger
          </div>
          <div class="palette-item" draggable="true" data-node="schedule-trigger">
            <i class="icon">‚è∞</i> Schedule Trigger
          </div>
          <div class="palette-item" draggable="true" data-node="webhook-trigger">
            <i class="icon">üåê</i> Webhook Trigger
          </div>
          
          <h3>File Operations</h3>
          <div class="palette-item" draggable="true" data-node="move-file">
            <i class="icon">üìã</i> Move File
          </div>
          <div class="palette-item" draggable="true" data-node="copy-file">
            <i class="icon">üìÑ</i> Copy File
          </div>
          <div class="palette-item" draggable="true" data-node="delete-file">
            <i class="icon">üóëÔ∏è</i> Delete File
          </div>
          <div class="palette-item" draggable="true" data-node="rename-file">
            <i class="icon">‚úèÔ∏è</i> Rename File
          </div>
          <div class="palette-item" draggable="true" data-node="archive-file">
            <i class="icon">üì¶</i> Archive File
          </div>
          <div class="palette-item" draggable="true" data-node="extract-archive">
            <i class="icon">üìÇ</i> Extract Archive
          </div>
          
          <h3>System Actions</h3>
          <div class="palette-item" draggable="true" data-node="run-command">
            <i class="icon">üíª</i> Run Command
          </div>
          <div class="palette-item" draggable="true" data-node="run-script">
            <i class="icon">üìú</i> Run Script
          </div>
          <div class="palette-item" draggable="true" data-node="ssh-command">
            <i class="icon">üîê</i> SSH Command
          </div>
          <div class="palette-item" draggable="true" data-node="send-file">
            <i class="icon">üì§</i> Send File (SFTP)
          </div>
          
          <h3>Integration</h3>
          <div class="palette-item" draggable="true" data-node="http-request">
            <i class="icon">üåç</i> HTTP Request
          </div>
          <div class="palette-item" draggable="true" data-node="database-query">
            <i class="icon">üóÑÔ∏è</i> Database Query
          </div>
          <div class="palette-item" draggable="true" data-node="send-email">
            <i class="icon">üìß</i> Send Email
          </div>
          <div class="palette-item" draggable="true" data-node="slack-message">
            <i class="icon">üí¨</i> Slack Message
          </div>
          
          <h3>Logic</h3>
          <div class="palette-item" draggable="true" data-node="condition">
            <i class="icon">‚ùì</i> Condition
          </div>
          <div class="palette-item" draggable="true" data-node="loop">
            <i class="icon">üîÑ</i> For-Each Loop
          </div>
          
          <h3>Platform</h3>
          <div class="palette-item" draggable="true" data-node="alert">
            <i class="icon">üîî</i> Send Alert
          </div>
          <div class="palette-item" draggable="true" data-node="javascript">
            <i class="icon">üìú</i> JavaScript
          </div>
        </div>
        
        <div id="drawflow"></div>

        <div class="splitter" id="splitter"></div>

        <div class="properties-panel" id="properties-panel">
          <div id="properties-content" style="height: 100%; padding: 15px;">
            <p class="no-selection" style="text-align: center; color: #6c757d; margin-top: 50px;">Select a node to edit properties</p>
          </div>
        </div>
      </div>
    </div>
  </main>
  
  <script src="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.js"></script>
  <script>
  let editor;
  let currentNodeId = null;
  let nodeIdCounter = 1;
  let currentWorkflowId = null;
  
  // Workflow data from server
  const workflowData = <%- workflow ? JSON.stringify(workflow) : 'null' %>;
  
  window.onload = function() {
    const container = document.getElementById('drawflow');
    
    // Clear any existing content to ensure clean initialization
    container.innerHTML = '';
    
    editor = new Drawflow(container);
    editor.reroute = true;
    editor.reroute_fix_curvature = true;
    editor.force_first_input = false;
    editor.line_path = 5;
    editor.start();
    
    // Force a reflow to ensure proper positioning
    container.offsetHeight;

    // Initialize splitter functionality
    initSplitter();

    // Handle drag and drop with fixed positioning
    const paletteItems = document.querySelectorAll('.palette-item');
    paletteItems.forEach(item => {
      item.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('node-type', item.dataset.node);
      });
    });
    
    container.addEventListener('drop', (e) => {
      e.preventDefault();
      const nodeType = e.dataTransfer.getData('node-type');
      if (nodeType) {
        // Use Drawflow's position calculation
        const pos_x = e.clientX * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)) - 
                      (editor.precanvas.getBoundingClientRect().x * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)));
        const pos_y = e.clientY * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)) - 
                      (editor.precanvas.getBoundingClientRect().y * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)));
        
        addNode(nodeType, pos_x, pos_y);
      }
    });
    
    container.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    // Handle node selection
    editor.on('nodeSelected', (id) => {
      currentNodeId = id;
      showNodeProperties(id);
    });
    
    editor.on('nodeUnselected', () => {
      currentNodeId = null;
      document.getElementById('properties-content').innerHTML = 
        '<p class="no-selection">Select a node to edit properties</p>';
    });
    
    // Load workflow if editing existing one
    if (workflowData) {
      currentWorkflowId = workflowData.id;
      const nameInput = document.getElementById('workflow-name');
      nameInput.value = workflowData.name || '';
      // Disable name editing when updating existing workflow
      nameInput.disabled = true;
      nameInput.title = 'Workflow name cannot be changed. Create a new workflow to use a different name.';
      
      // Load the drawflow data if it exists
      if (workflowData.config && workflowData.config.drawflow) {
        try {
          editor.import(workflowData.config.drawflow);
          console.log('Loaded workflow:', workflowData.name);
          
          // Update nodeIdCounter to avoid ID conflicts
          const nodes = workflowData.config.drawflow.drawflow?.Home?.data || {};
          const maxId = Math.max(...Object.keys(nodes).map(id => parseInt(id) || 0), 0);
          nodeIdCounter = maxId + 1;
        } catch (err) {
          console.error('Error loading workflow:', err);
          alert('Error loading workflow data. Starting with empty canvas.');
        }
      }
    }
  };
  
  function addNode(type, pos_x, pos_y) {
    const nodeConfigs = {
      'file-trigger': {
        name: 'File Trigger',
        class: 'node-trigger',
        inputs: 0,
        outputs: 1,
        data: { path: '', pattern: '*', events: ['create', 'modify'] }
      },
      'schedule-trigger': {
        name: 'Schedule Trigger',
        class: 'node-trigger',
        inputs: 0,
        outputs: 1,
        data: { cron: '0 * * * *' }
      },
      'webhook-trigger': {
        name: 'Webhook Trigger',
        class: 'node-trigger',
        inputs: 0,
        outputs: 1,
        data: { path: '/webhook', method: 'POST' }
      },
      'move-file': {
        name: 'Move File',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { source: '', destination: '' }
      },
      'copy-file': {
        name: 'Copy File',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { source: '', destination: '' }
      },
      'delete-file': {
        name: 'Delete File',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { path: '' }
      },
      'run-command': {
        name: 'Run Command',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { command: '', args: [] }
      },
      'ssh-command': {
        name: 'SSH Command',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { host: '', command: '' }
      },
      'send-file': {
        name: 'Send File (SFTP)',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { source: '', destination: '', host: '' }
      },
      'http-request': {
        name: 'HTTP Request',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { url: '', method: 'GET', headers: {}, body: '' }
      },
      'condition': {
        name: 'Condition',
        class: 'node-condition',
        inputs: 1,
        outputs: 2,
        data: { expression: '', trueLabel: 'True', falseLabel: 'False' }
      },
      'loop': {
        name: 'For-Each Loop',
        class: 'node-condition',
        inputs: 1,
        outputs: 2,
        data: { items: '', itemVar: 'item' }
      },
      'alert': {
        name: 'Send Alert',
        class: 'node-output',
        inputs: 1,
        outputs: 0,
        data: { level: 'info', message: '' }
      },
      'javascript': {
        name: 'JavaScript',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { code: '// Your code here\\nreturn data;' }
      },
      'rename-file': {
        name: 'Rename File',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { source: '', newName: '' }
      },
      'archive-file': {
        name: 'Archive File',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { source: '', destination: '', format: 'zip' }
      },
      'extract-archive': {
        name: 'Extract Archive',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { source: '', destination: '' }
      },
      'run-script': {
        name: 'Run Script',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { script: '', interpreter: 'bash' }
      },
      'database-query': {
        name: 'Database Query',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { connection: '', query: '', params: [] }
      },
      'send-email': {
        name: 'Send Email',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { to: '', subject: '', body: '', attachments: [] }
      },
      'slack-message': {
        name: 'Slack Message',
        class: 'node-action',
        inputs: 1,
        outputs: 1,
        data: { webhook: '', channel: '', message: '' }
      }
    };
    
    const config = nodeConfigs[type];
    if (!config) return;
    
    const nodeId = (nodeIdCounter++);
    
    // Special handling for condition nodes with multiple outputs
    let nodeContent = `<small style="color: #666;">${type}</small>`;
    if (type === 'condition') {
      nodeContent = `
        <small style="color: #666;">Condition</small>
        <div style="margin-top: 5px; font-size: 10px;">
          <div>‚úì ${config.data.trueLabel || 'True'}</div>
          <div>‚úó ${config.data.falseLabel || 'False'}</div>
        </div>
      `;
    } else if (type === 'loop') {
      nodeContent = `
        <small style="color: #666;">Loop</small>
        <div style="margin-top: 5px; font-size: 10px;">
          <div>‚Üí Each Item</div>
          <div>‚Üì Continue</div>
        </div>
      `;
    }
    
    const html = `
      <div class="${config.class}">
        <div class="node-header">${config.name}</div>
        <div class="node-content">
          ${nodeContent}
        </div>
      </div>
    `;
    
    editor.addNode(
      type,
      config.inputs,
      config.outputs,
      pos_x,
      pos_y,
      config.class,
      config.data,
      html
    );
    
    console.log('Added node:', type, 'at', pos_x, pos_y);
  }
  
  function showNodeProperties(id) {
    const nodeInfo = editor.getNodeFromId(id);
    const data = nodeInfo.data;
    const type = nodeInfo.name;

    // Create tabs for properties and inputs
    let propertiesHtml = `
      <div class="property-tabs" style="display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #dee2e6;">
        <button class="tab-button" onclick="showPropertiesTab('properties')"
                style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px 4px 0 0; cursor: pointer;"
                id="properties-tab-btn">Properties</button>
        <button class="tab-button" onclick="showPropertiesTab('inputs')"
                style="padding: 8px 16px; background: #e9ecef; color: #495057; border: none; border-radius: 4px 4px 0 0; cursor: pointer;"
                id="inputs-tab-btn">Available Inputs</button>
      </div>
      <div id="properties-tab-content" style="display: block;">
    `;

    // Generate property fields based on node type
    const fields = getNodeFields(type);
    fields.forEach(field => {
      const value = data[field.key] || field.default || '';
      propertiesHtml += `
        <div class="property-field">
          <label>${field.label}</label>
          ${generateFieldInput(field, value)}
        </div>
      `;
    });

    propertiesHtml += `
      <button class="btn btn-sm btn-primary" onclick="updateNodeProperties()">Update</button>
      </div>
      <div id="inputs-tab-content" style="display: none;">
        ${generateInputsTab(id)}
      </div>
    `;

    document.getElementById('properties-content').innerHTML = propertiesHtml;
  }

  // Show/hide property tabs
  function showPropertiesTab(tab) {
    if (tab === 'properties') {
      document.getElementById('properties-tab-content').style.display = 'block';
      document.getElementById('inputs-tab-content').style.display = 'none';
      document.getElementById('properties-tab-btn').style.background = '#007bff';
      document.getElementById('properties-tab-btn').style.color = 'white';
      document.getElementById('inputs-tab-btn').style.background = '#e9ecef';
      document.getElementById('inputs-tab-btn').style.color = '#495057';
    } else {
      document.getElementById('properties-tab-content').style.display = 'none';
      document.getElementById('inputs-tab-content').style.display = 'block';
      document.getElementById('properties-tab-btn').style.background = '#e9ecef';
      document.getElementById('properties-tab-btn').style.color = '#495057';
      document.getElementById('inputs-tab-btn').style.background = '#007bff';
      document.getElementById('inputs-tab-btn').style.color = 'white';
    }
  }

  // Generate the inputs tab content
  function generateInputsTab(nodeId) {
    const nodeInfo = editor.getNodeFromId(nodeId);
    const nodeType = nodeInfo.name;

    // Get all nodes connected to inputs of this node
    const inputs = getNodeInputs(nodeId);
    const outputs = getNodeOutputs(nodeType, nodeInfo.data);

    let html = '<div style="padding: 10px;">';
    html += '<h5>Available Input Variables</h5>';

    if (inputs.length === 0) {
      html += '<p style="color: #6c757d; font-style: italic;">No input variables available</p>';
    } else {
      html += `<table style="width: 100%; border-collapse: collapse;">
        <thead>
          <tr style="border-bottom: 2px solid #dee2e6;">
            <th style="text-align: left; padding: 8px;">Variable</th>
            <th style="text-align: left; padding: 8px;">Description</th>
            <th style="width: 60px; text-align: center; padding: 8px;">Copy</th>
          </tr>
        </thead>
        <tbody>`;
      inputs.forEach(variable => {
        const varString = `{{.${variable.name}}}`;
        html += `
          <tr style="border-bottom: 1px solid #e9ecef;">
            <td style="padding: 8px; font-family: monospace; font-weight: bold;">${varString}</td>
            <td style="padding: 8px; color: #6c757d;">${variable.description}</td>
            <td style="padding: 8px; text-align: center;">
              <button onclick="copyToClipboard('${varString}')"
                      style="padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;"
                      onmouseover="this.style.background='#0056b3'"
                      onmouseout="this.style.background='#007bff'">
                üìã
              </button>
            </td>
          </tr>`;
      });
      html += '</tbody></table>';
    }

    html += '<h5 style="margin-top: 20px;">This Node Outputs</h5>';
    if (outputs.length === 0) {
      html += '<p style="color: #6c757d; font-style: italic;">This node produces no additional outputs</p>';
    } else {
      html += `<table style="width: 100%; border-collapse: collapse;">
        <thead>
          <tr style="border-bottom: 2px solid #dee2e6;">
            <th style="text-align: left; padding: 8px;">Variable</th>
            <th style="text-align: left; padding: 8px;">Description</th>
            <th style="width: 60px; text-align: center; padding: 8px;">Copy</th>
          </tr>
        </thead>
        <tbody>`;
      outputs.forEach(variable => {
        const varString = `{{.${variable.name}}}`;
        html += `
          <tr style="border-bottom: 1px solid #e9ecef;">
            <td style="padding: 8px; font-family: monospace; font-weight: bold; color: #28a745;">${varString}</td>
            <td style="padding: 8px; color: #6c757d;">${variable.description}</td>
            <td style="padding: 8px; text-align: center;">
              <button onclick="copyToClipboard('${varString}')"
                      style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;"
                      onmouseover="this.style.background='#218838'"
                      onmouseout="this.style.background='#28a745'">
                üìã
              </button>
            </td>
          </tr>`;
      });
      html += '</tbody></table>';
    }

    html += '</div>';
    return html;
  }

  // Copy text to clipboard
  function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
      // Show brief feedback
      const btn = event.target;
      const originalText = btn.innerHTML;
      btn.innerHTML = '‚úì';
      btn.style.background = '#28a745';
      setTimeout(() => {
        btn.innerHTML = originalText;
      }, 1000);
    }).catch(err => {
      console.error('Failed to copy:', err);
      alert('Failed to copy to clipboard');
    });
  }

  // Initialize splitter for resizing panels
  function initSplitter() {
    const splitter = document.getElementById('splitter');
    const drawflow = document.getElementById('drawflow');
    const propertiesPanel = document.getElementById('properties-panel');
    const editorLayout = document.querySelector('.editor-layout');

    let isResizing = false;

    splitter.addEventListener('mousedown', (e) => {
      isResizing = true;
      document.body.style.cursor = 'col-resize';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;

      const layoutRect = editorLayout.getBoundingClientRect();
      const newDrawflowWidth = e.clientX - layoutRect.left - 220 - 8; // Subtract palette width and splitter
      const newPanelWidth = layoutRect.width - newDrawflowWidth - 220 - 8;

      // Enforce minimum and maximum widths
      if (newPanelWidth >= 250 && newPanelWidth <= 600 && newDrawflowWidth >= 300) {
        drawflow.style.flex = `1 1 ${newDrawflowWidth}px`;
        propertiesPanel.style.width = `${newPanelWidth}px`;
      }
    });

    document.addEventListener('mouseup', () => {
      isResizing = false;
      document.body.style.cursor = '';
    });
  }

  // Get inputs available to a node
  function getNodeInputs(nodeId) {
    const nodeInfo = editor.getNodeFromId(nodeId);
    const connections = nodeInfo.inputs.input_1?.connections || [];

    let allInputs = [];

    // Add trigger variables if this is the first node
    const firstNode = connections.length === 0;
    if (firstNode) {
      allInputs = getTriggerVariables();
    }

    // Collect outputs from all connected input nodes
    connections.forEach(conn => {
      const sourceNode = editor.getNodeFromId(conn.node);
      const sourceOutputs = getNodeOutputs(sourceNode.name, sourceNode.data);

      // Add source outputs to available inputs
      sourceOutputs.forEach(output => {
        // Check if variable already exists (avoid duplicates)
        if (!allInputs.find(v => v.name === output.name)) {
          allInputs.push(output);
        }
      });

      // Recursively get inputs from the source node
      const sourceInputs = getNodeInputs(conn.node);
      sourceInputs.forEach(input => {
        if (!allInputs.find(v => v.name === input.name)) {
          allInputs.push(input);
        }
      });
    });

    return allInputs;
  }

  // Get trigger variables based on the actual trigger type in the workflow
  function getTriggerVariables() {
    // Find the trigger node in the workflow
    const nodes = editor.export().drawflow.Home.data;
    let triggerType = null;

    for (const nodeId in nodes) {
      const node = nodes[nodeId];
      if (node.name.endsWith('-trigger')) {
        triggerType = node.name;
        break;
      }
    }

    // Return variables based on trigger type
    if (triggerType === 'file-trigger' || triggerType === 'filewatcher-trigger') {
      return [
        { name: 'trigger', description: 'Trigger type (file or filewatcher)' },
        { name: 'file', description: 'Full path to the file' },
        { name: 'fileName', description: 'Just the filename without path' },
        { name: 'directory', description: 'Directory containing the file' },
        { name: 'event', description: 'Event type (CREATE, WRITE, etc.)' },
        { name: 'timestamp', description: 'When the trigger occurred' }
      ];
    } else if (triggerType === 'schedule-trigger') {
      return [
        { name: 'trigger', description: 'Trigger type (schedule)' },
        { name: 'timestamp', description: 'When the trigger occurred' },
        { name: 'scheduledTime', description: 'The scheduled execution time' }
      ];
    } else if (triggerType === 'webhook-trigger') {
      return [
        { name: 'trigger', description: 'Trigger type (webhook)' },
        { name: 'webhookData', description: 'Data received from webhook' },
        { name: 'webhookHeaders', description: 'Headers from webhook request' },
        { name: 'timestamp', description: 'When the trigger occurred' }
      ];
    } else {
      // No trigger or unknown trigger - for workflows meant to be called
      return [
        { name: 'trigger', description: 'How the workflow was triggered' },
        { name: 'timestamp', description: 'When the workflow started' }
      ];
    }
  }

  // Node type definitions with outputs
  const NodeTypes = {
    // Triggers
    'file-trigger': {
      outputs: []  // Trigger outputs are handled separately
    },
    'filewatcher-trigger': {
      outputs: []  // Trigger outputs are handled separately
    },
    'schedule-trigger': {
      outputs: []  // Trigger outputs are handled separately
    },
    'webhook-trigger': {
      outputs: []  // Trigger outputs are handled separately
    },

    // File operations
    'copy-file': {
      outputs: [
        { name: 'destinationFile', description: 'Path to the copied file' },
        { name: 'success', description: 'Whether the copy was successful' }
      ]
    },
    'move-file': {
      outputs: [
        { name: 'destinationFile', description: 'Path to the moved file' },
        { name: 'success', description: 'Whether the move was successful' }
      ]
    },
    'delete-file': {
      outputs: [
        { name: 'success', description: 'Whether the deletion was successful' }
      ]
    },
    'rename-file': {
      outputs: [
        { name: 'newFile', description: 'Path to the renamed file' },
        { name: 'success', description: 'Whether the rename was successful' }
      ]
    },
    'archive-file': {
      outputs: [
        { name: 'archivePath', description: 'Path to the created archive' },
        { name: 'success', description: 'Whether the archive was created successfully' }
      ]
    },
    'extract-archive': {
      outputs: [
        { name: 'extractPath', description: 'Path where files were extracted' },
        { name: 'fileCount', description: 'Number of files extracted' },
        { name: 'success', description: 'Whether extraction was successful' }
      ]
    },

    // System actions
    'command': {
      outputs: [
        { name: 'output', description: 'Command output' },
        { name: 'exitCode', description: 'Command exit code' },
        { name: 'success', description: 'Whether command succeeded (exit code 0)' }
      ]
    },
    'run-command': {
      outputs: [
        { name: 'output', description: 'Command output' },
        { name: 'exitCode', description: 'Command exit code' },
        { name: 'success', description: 'Whether command succeeded' }
      ]
    },
    'run-script': {
      outputs: [
        { name: 'output', description: 'Script output' },
        { name: 'exitCode', description: 'Script exit code' },
        { name: 'success', description: 'Whether script succeeded' }
      ]
    },
    'ssh-command': {
      outputs: [
        { name: 'output', description: 'SSH command output' },
        { name: 'exitCode', description: 'Remote command exit code' },
        { name: 'success', description: 'Whether SSH command succeeded' }
      ]
    },
    'send-file': {
      outputs: [
        { name: 'remotePath', description: 'Path on remote server' },
        { name: 'bytesTransferred', description: 'Number of bytes transferred' },
        { name: 'success', description: 'Whether file transfer succeeded' }
      ]
    },

    // Integration
    'http-request': {
      outputs: [
        { name: 'response', description: 'HTTP response body' },
        { name: 'statusCode', description: 'HTTP status code' },
        { name: 'headers', description: 'Response headers' }
      ]
    },
    'database-query': {
      outputs: [
        { name: 'results', description: 'Query results' },
        { name: 'rowCount', description: 'Number of rows affected/returned' },
        { name: 'success', description: 'Whether query succeeded' }
      ]
    },
    'send-email': {
      outputs: [
        { name: 'messageId', description: 'Email message ID' },
        { name: 'success', description: 'Whether email was sent' }
      ]
    },
    'slack-message': {
      outputs: [
        { name: 'messageId', description: 'Slack message ID' },
        { name: 'channel', description: 'Channel where message was sent' },
        { name: 'success', description: 'Whether message was sent' }
      ]
    },

    // Logic
    'condition': {
      outputs: [
        { name: 'conditionResult', description: 'Result of the condition (true/false)' }
      ]
    },
    'loop': {
      outputs: [
        { name: 'currentItem', description: 'Current item being processed' },
        { name: 'currentIndex', description: 'Current loop index' },
        { name: 'totalItems', description: 'Total number of items' }
      ]
    },

    // Platform
    'alert': {
      outputs: []  // Alerts don't produce outputs
    },
    'log': {
      outputs: []  // Logs don't produce outputs
    },
    'wait': {
      outputs: []  // Wait doesn't produce outputs
    },
    'javascript': {
      outputs: [
        { name: 'result', description: 'JavaScript execution result' },
        { name: 'success', description: 'Whether execution succeeded' }
      ]
    }
  };

  // Get outputs produced by a node type
  function getNodeOutputs(nodeType, nodeData) {
    const nodeDefinition = NodeTypes[nodeType];
    if (nodeDefinition && nodeDefinition.outputs) {
      return nodeDefinition.outputs;
    }
    return [];
  }

  function getNodeFields(type) {
    const fieldConfigs = {
      'file-trigger': [
        { key: 'path', label: 'Watch Path', type: 'text' },
        { key: 'pattern', label: 'File Pattern', type: 'text', default: '*' }
      ],
      'filewatcher-trigger': [
        { key: 'description', label: 'Description', type: 'text',
          placeholder: 'This workflow is designed to be called from file watchers' }
      ],
      'schedule-trigger': [
        { key: 'cron', label: 'Cron Expression', type: 'text', default: '0 * * * *' }
      ],
      'run-command': [
        { key: 'command', label: 'Command', type: 'text' },
        { key: 'args', label: 'Arguments', type: 'text' }
      ],
      'move-file': [
        { key: 'source', label: 'Source Path', type: 'text' },
        { key: 'destination', label: 'Destination Path', type: 'text' }
      ],
      'alert': [
        { key: 'level', label: 'Alert Level', type: 'select', options: ['info', 'warning', 'error', 'critical'] },
        { key: 'message', label: 'Message', type: 'textarea' }
      ],
      'javascript': [
        { key: 'code', label: 'JavaScript Code', type: 'textarea' }
      ],
      'copy-file': [
        { key: 'source', label: 'Source Path', type: 'text' },
        { key: 'destination', label: 'Destination Path', type: 'text' }
      ],
      'delete-file': [
        { key: 'path', label: 'File Path', type: 'text' }
      ],
      'rename-file': [
        { key: 'source', label: 'Source Path', type: 'text' },
        { key: 'newName', label: 'New Name', type: 'text' }
      ],
      'archive-file': [
        { key: 'source', label: 'Source Path', type: 'text' },
        { key: 'destination', label: 'Archive Path', type: 'text' },
        { key: 'format', label: 'Format', type: 'select', options: ['zip', 'tar', 'tar.gz', '7z'] }
      ],
      'extract-archive': [
        { key: 'source', label: 'Archive Path', type: 'text' },
        { key: 'destination', label: 'Extract To', type: 'text' }
      ],
      'run-script': [
        { key: 'script', label: 'Script Path', type: 'text' },
        { key: 'interpreter', label: 'Interpreter', type: 'select', options: ['bash', 'python', 'node', 'powershell'] }
      ],
      'ssh-command': [
        { key: 'host', label: 'Host/Agent ID', type: 'text' },
        { key: 'command', label: 'Command', type: 'text' }
      ],
      'send-file': [
        { key: 'source', label: 'Source Path', type: 'text' },
        { key: 'destination', label: 'Remote Path', type: 'text' },
        { key: 'host', label: 'Host/Agent ID', type: 'text' }
      ],
      'http-request': [
        { key: 'url', label: 'URL', type: 'text' },
        { key: 'method', label: 'Method', type: 'select', options: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'] },
        { key: 'headers', label: 'Headers (JSON)', type: 'textarea' },
        { key: 'body', label: 'Body', type: 'textarea' }
      ],
      'database-query': [
        { key: 'connection', label: 'Connection String', type: 'text' },
        { key: 'query', label: 'SQL Query', type: 'textarea' }
      ],
      'send-email': [
        { key: 'to', label: 'To', type: 'text' },
        { key: 'subject', label: 'Subject', type: 'text' },
        { key: 'body', label: 'Body', type: 'textarea' }
      ],
      'slack-message': [
        { key: 'webhook', label: 'Webhook URL', type: 'text' },
        { key: 'channel', label: 'Channel', type: 'text' },
        { key: 'message', label: 'Message', type: 'textarea' }
      ],
      'webhook-trigger': [
        { key: 'path', label: 'Webhook Path', type: 'text' },
        { key: 'method', label: 'HTTP Method', type: 'select', options: ['GET', 'POST', 'PUT'] }
      ],
      'condition': [
        { key: 'expression', label: 'JavaScript Expression', type: 'textarea' },
        { key: 'trueLabel', label: 'True Output Label', type: 'text', default: 'True' },
        { key: 'falseLabel', label: 'False Output Label', type: 'text', default: 'False' }
      ],
      'loop': [
        { key: 'items', label: 'Items Expression', type: 'text' },
        { key: 'itemVar', label: 'Item Variable', type: 'text', default: 'item' }
      ]
    };
    
    return fieldConfigs[type] || [];
  }
  
  function generateFieldInput(field, value) {
    if (field.type === 'textarea') {
      return `<textarea class="form-input" data-key="${field.key}">${value}</textarea>`;
    } else if (field.type === 'select') {
      const options = field.options.map(opt => 
        `<option value="${opt}" ${opt === value ? 'selected' : ''}>${opt}</option>`
      ).join('');
      return `<select class="form-input" data-key="${field.key}">${options}</select>`;
    } else {
      return `<input type="${field.type || 'text'}" class="form-input" data-key="${field.key}" value="${value}">`;
    }
  }
  
  function updateNodeProperties() {
    if (!currentNodeId) return;
    
    const inputs = document.querySelectorAll('#properties-content .form-input');
    const newData = {};
    
    inputs.forEach(input => {
      const key = input.dataset.key;
      newData[key] = input.value;
    });
    
    editor.updateNodeDataFromId(currentNodeId, newData);
  }
  
  function saveWorkflow() {
    const name = document.getElementById('workflow-name').value;
    if (!name) {
      alert('Please enter a workflow name');
      return;
    }
    
    const drawflowData = editor.export();
    const workflowStructure = convertDrawflowToSteps(drawflowData);
    const config = {
      id: currentWorkflowId || 'wf-' + Date.now(),
      name: name,
      enabled: true,
      drawflow: drawflowData,
      trigger: workflowStructure.trigger,
      steps: workflowStructure.steps
    };
    
    const url = currentWorkflowId ? `/api/workflows/${currentWorkflowId}` : '/api/workflows';
    const method = currentWorkflowId ? 'PUT' : 'POST';
    
    fetch(url, {
      method: method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        name: name,
        description: currentWorkflowId ? 'Updated with visual editor' : 'Created with visual editor',
        config: config
      })
    })
    .then(r => r.json())
    .then(data => {
      alert(currentWorkflowId ? 'Workflow updated successfully!' : 'Workflow created successfully!');
      window.location.href = '/workflows';
    })
    .catch(err => alert('Failed to save workflow: ' + err.message));
  }
  
  function convertDrawflowToSteps(drawflowData) {
    // Convert Drawflow format to workflow steps format
    const steps = [];
    let trigger = null;
    const nodes = drawflowData.drawflow?.Home?.data || {};
    
    for (const [id, node] of Object.entries(nodes)) {
      // Check if this is a trigger node (no inputs)
      if (node.name.includes('-trigger')) {
        trigger = {
          type: node.name.replace('-trigger', ''),
          config: node.data
        };
        // Get steps connected to this trigger
        if (node.outputs?.output_1?.connections) {
          trigger.startSteps = node.outputs.output_1.connections.map(c => 'step-' + c.node);
        }
      } else {
        // Regular step node
        steps.push({
          id: 'step-' + id,
          type: node.name,
          name: node.name,
          config: node.data,
          next: node.outputs?.output_1?.connections?.map(c => 'step-' + c.node) || []
        });
      }
    }
    
    return {
      trigger: trigger || { type: 'manual', config: {} },
      steps: steps
    };
  }
  
  function clearWorkflow() {
    if (confirm('Clear the current workflow?')) {
      editor.clear();
    }
  }
  
  function exportWorkflow() {
    const data = editor.export();
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'workflow.json';
    a.click();
  }
  
  function importWorkflow() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);
          editor.import(data);
        } catch (err) {
          alert('Invalid workflow file');
        }
      };
      reader.readAsText(file);
    };
    input.click();
  }
  </script>
</body>
</html>